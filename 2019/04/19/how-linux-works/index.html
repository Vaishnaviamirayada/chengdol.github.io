<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Great book for all Linux developers and administrators! Just note for future quick revisit! Chapter1. The Big pictureThe most effective way to understand how an operating system works is through abstr">
<meta name="keywords" content="linux">
<meta property="og:type" content="article">
<meta property="og:title" content="How Linux Works, 2nd Edition">
<meta property="og:url" content="http://yoursite.com/2019/04/19/how-linux-works/index.html">
<meta property="og:site_name" content="海胆阶段&#39;s Blog">
<meta property="og:description" content="Great book for all Linux developers and administrators! Just note for future quick revisit! Chapter1. The Big pictureThe most effective way to understand how an operating system works is through abstr">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://drive.google.com/uc?id=1e0ziORmoEx6zPk6J6qEid26aWl-zw21G">
<meta property="og:image" content="https://drive.google.com/uc?id=1Hy8vWUIBuo33oH976PNEkVzvAOzCuyKJ">
<meta property="og:updated_time" content="2019-05-07T17:06:49.312Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="How Linux Works, 2nd Edition">
<meta name="twitter:description" content="Great book for all Linux developers and administrators! Just note for future quick revisit! Chapter1. The Big pictureThe most effective way to understand how an operating system works is through abstr">
<meta name="twitter:image" content="https://drive.google.com/uc?id=1e0ziORmoEx6zPk6J6qEid26aWl-zw21G">






  <link rel="canonical" href="http://yoursite.com/2019/04/19/how-linux-works/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>How Linux Works, 2nd Edition | 海胆阶段's Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">海胆阶段's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags<span class="badge">36</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories<span class="badge">11</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives<span class="badge">42</span></a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/19/how-linux-works/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="海胆阶段">
      <meta itemprop="description" content="骐骥一跃，不能十步；驽马十驾，功在不舍">
      <meta itemprop="image" content="/images/cuishao.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="海胆阶段's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">How Linux Works, 2nd Edition

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-19 09:52:29" itemprop="dateCreated datePublished" datetime="2019-04-19T09:52:29-07:00">2019-04-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-05-07 10:06:49" itemprop="dateModified" datetime="2019-05-07T10:06:49-07:00">2019-05-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Great book for all Linux developers and administrators! Just note for future quick revisit!</p>
<h3 id="Chapter1-The-Big-picture"><a href="#Chapter1-The-Big-picture" class="headerlink" title="Chapter1. The Big picture"></a>Chapter1. The Big picture</h3><p>The most effective way to understand how an operating system works is through abstraction—a fancy way of saying that you can ignore most of the details.</p>
<p>The <code>kernel</code> is software residing in memory that tells the CPU what to do. The kernel manages the hardware and acts primarily as an interface between the hardware and any running program.</p>
<p>Processes—the running programs that the kernel manages—collectively make up the system’s upper level, called <code>user space</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------------------------------------------------+</span><br><span class="line">|                                                                         |</span><br><span class="line">|  User process                                                           |</span><br><span class="line">|                                                                         |</span><br><span class="line">|   +-------------------+   +-----------------+    +---------------+      |</span><br><span class="line">|   |  GUI              |   |  Servers        |    |  Shell        |      |</span><br><span class="line">|   |                   |   |                 |    |               |      |</span><br><span class="line">|   +-------------------+   +-----------------+    +---------------+      |</span><br><span class="line">|                                                                         |</span><br><span class="line">+-------------------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-------------------------------------------------------------------------+</span><br><span class="line">|                                                                         |</span><br><span class="line">|  Linux kernel                                                           |</span><br><span class="line">|  +--------------+     +--------------------------+                      |</span><br><span class="line">|  |  system calls|     |   process management     |                      |</span><br><span class="line">|  +--------------+     +--------------------------+                      |</span><br><span class="line">|                                                                         |</span><br><span class="line">|  +---------------------+        +-------------------------------+       |</span><br><span class="line">|  |  device driver      |        |   memory management           |       |</span><br><span class="line">|  +---------------------+        +-------------------------------+       |</span><br><span class="line">+-------------------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line">+-------------------------------------------------------------------------+</span><br><span class="line">|                                                                         |</span><br><span class="line">|  Hardware                                                               |</span><br><span class="line">|                                                                         |</span><br><span class="line">|  +-------------------+   +-------------------+   +---------------+      |</span><br><span class="line">|  |   CPU             |   |    RAM            |   |  Disk         |      |</span><br><span class="line">|  +-------------------+   +-------------------+   +---------------+      |</span><br><span class="line">|  +---------------------+                                                |</span><br><span class="line">|  |   Network           |                                                |</span><br><span class="line">|  +---------------------+                                                |</span><br><span class="line">+-------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>There is a critical difference between the ways that the kernel and user processes run: The kernel runs in kernel mode, and the user processes run in user mode. Code running in kernel mode has unrestricted access to the processor and main memory. This is a powerful but dangerous privilege that allows a kernel process to easily crash the entire system. The area that only the kernel can access is called kernel space.</p>
<p>User mode, in comparison, restricts access to a (usually quite small) subset of memory and safe CPU operations. User space refers to the parts of main memory that the user processes can access. If a process makes a mistake and crashes, the consequences are limited and can be cleaned up by the kernel. This means that if your web browser crashes, it probably won’t take down the scientific computation that you’ve been running in the background for days.</p>
<h4 id="Hardware"><a href="#Hardware" class="headerlink" title="Hardware"></a>Hardware</h4><p>A CPU is just an operator on memory; it reads its instructions and data from the memory and writes data back out to the memory.</p>
<p>You’ll often hear the term <code>state</code> in reference to memory, processes, the kernel, and other parts of a computer system. Strictly speaking, a state is a particular arrangement of bits. For example, if you have four bits in your memory, 0110, 0001, and 1011 represent three different states.</p>
<p>The term <code>image</code> refers to a particular physical arrangement of bits.</p>
<h4 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h4><p>Nearly everything that the kernel does revolves around main memory. One of the kernel’s tasks is to split memory into many subdivisions, and it must maintain certain state information about those subdivisions at all times. Each process gets its own share of memory, and the kernel must ensure that each process keeps to its share.</p>
<p>The kernel is in charge of managing tasks in four general system areas:<br><strong>Processes</strong>. The kernel is responsible for determining which processes are allowed to use the CPU.</p>
<p><strong>Memory</strong>. The kernel needs to keep track of all memory—what is currently allocated to a particular process, what might be shared between processes, and what is free.</p>
<p><strong>Device drivers</strong>. The kernel acts as an interface between hardware (such as a disk) and processes. It’s usually the kernel’s job to operate the hardware.</p>
<p><strong>System calls and support</strong>. Processes normally use system calls to communicate with the kernel.</p>
<p>The act of one process giving up control of the CPU to another process is called a context switch.</p>
<p>The kernel is responsible for context switching. To understand how this works, let’s think about a situation in which a process is running in user mode but its time slice is up. Here’s what happens:</p>
<ol>
<li>The CPU (the actual hardware) interrupts the current process based on an internal timer, switches into kernel mode, and hands control back to the kernel.</li>
<li>The kernel records the current state of the CPU and memory, which will be essential to resuming the process that was just interrupted.</li>
<li>The kernel performs any tasks that might have come up during the preceding time slice (such as collecting data from input and output, or I/O, operations).</li>
<li>The kernel is now ready to let another process run. The kernel analyzes the list of processes that are ready to run and chooses one.</li>
<li>The kernel prepares the memory for this new process, and then prepares the CPU.</li>
<li>The kernel tells the CPU how long the time slice for the new process will last.</li>
<li>The kernel switches the CPU into user mode and hands control of the CPU to the process.</li>
</ol>
<p>The context switch answers the important question of <em>when</em> the kernel runs. The answer is that it runs <em>between</em> process time slices during a context switch.</p>
<p>Modern CPUs include a <code>memory management unit (MMU)</code> that enables a memory access scheme called <code>virtual memory</code>. When using virtual memory, a process does not directly access the memory by its physical location in the hardware. Instead, the kernel sets up each process to act as if it had an entire machine to itself. When the process accesses some of its memory, the MMU intercepts the access and uses a memory address map to translate the memory location from the process into an actual physical memory location on the machine. The kernel must still initialize and continuously maintain and alter this memory address map. For example, during a context switch, the kernel has to change the map from the outgoing process to the incoming process.</p>
<blockquote>
<p>The implementation of a memory address map is called a page table.</p>
</blockquote>
<p>The kernel’s role with devices is pretty simple. A device is typically accessible only in kernel mode because improper access (such as a user process asking to turn off the power) could crash the machine. Another problem is that different devices rarely have the same programming interface, even if the devices do the same thing, such as two different network cards. Therefore, device drivers have traditionally been part of the kernel.</p>
<p>There are several other kinds of kernel features available to user processes. For example, <code>system calls</code> (or syscalls) perform specific tasks that a user process alone cannot do well or at all. For example, the acts of opening, reading, and writing files all involve system calls.</p>
<p>Other than init, <em>all</em> user processes on a Linux system start as a result of <code>fork()</code>, and most of the time, you also run <code>exec()</code> to start a new program instead of running a copy of an existing process.</p>
<h4 id="User-Space"><a href="#User-Space" class="headerlink" title="User Space"></a>User Space</h4><p>As mentioned earlier, the main memory that the kernel allocates for user processes is called <code>user space</code>. Because a process is simply a state (or image) in memory, user space also refers to the memory for the entire collection of running processes. </p>
<h4 id="Users"><a href="#Users" class="headerlink" title="Users"></a>Users</h4><p>A <code>user</code> is an entity that can run processes and own files. A user is associated with a username. For example, a system could have a user named billyjoe. However, the kernel does not manage the usernames; instead, it identifies users by simple numeric identifiers called userids.</p>
<p>Users exist primarily to support permissions and boundaries.</p>
<p>In addition, as powerful as the root user is, it still runs in the operating system’s user mode, not kernel mode.</p>
<p><code>Groups</code> are sets of users. The primary purpose of groups is to allow a user to share file access to other users in a group.</p>
<h3 id="Chapter-2-Basic-Commands-and-Directory-Hierarchy"><a href="#Chapter-2-Basic-Commands-and-Directory-Hierarchy" class="headerlink" title="Chapter 2. Basic Commands and Directory Hierarchy"></a>Chapter 2. Basic Commands and Directory Hierarchy</h3><p>Some resources:<br><em>UNIX for the Impatient</em><br><em>Learning the UNIX Operating System</em></p>
<p>The <code>shell</code> is one of the most important parts of a Unix system. A shell is a program that runs commands. The shell also serves as a small programming environment.</p>
<p>Many important parts of the system are actually <code>shell scripts</code>—text files that contain a sequence of shell commands. </p>
<p>There are many different Unix shells, but all derive several of their features from the <code>Bourne shell</code> (/bin/sh), a standard shell developed at Bell Labs for early versions of Unix. Every Unix system needs the Bourne shell in order to function correctly, as you will see throughout this book.</p>
<p>Linux uses an enhanced version of the Bourne shell called <code>bash</code> or the “Bourne-again” shell. The bash shell is the default shell on most Linux distributions, and /bin/sh is normally a link to bash on a Linux system. </p>
<blockquote>
<p><code>cat</code> command: The command is called cat because it performs concatenation when it prints the contents of more than one file.</p>
</blockquote>
<p>Pressing <code>CTRL-D</code> on an empty line stops the current standard input entry from the terminal (and often terminates a program). Don’t confuse this with <code>CTRL-C</code>, which terminates a program regardless of its input or output.</p>
<blockquote>
<p>Unix filenames do not need extensions and often do not carry them.</p>
</blockquote>
<p><code>shell globs</code> don’t match dot files unless you explicitly use a pattern such as <code>.*</code>. This is why <code>rm -rf ./*</code> doesn’t remove hidden objects.</p>
<blockquote>
<p>You can run into problems with globs because <code>.*</code> matches <code>.</code> and <code>..</code> (the current and parent directories)</p>
</blockquote>
<p>The shell can store temporary variables, called <code>shell variables</code>, containing the values of text strings. Shell variables are very useful for keeping track of values in scripts, and some shell variables control the way the shell behaves.</p>
<p>An <code>environment variable</code> is like a shell variable, but it’s not specific to the shell. All processes on Unix systems have environment variable storage. The main difference between environment and shell variables is that the operating system passes all of your shell’s <code>environment variables</code> to programs that the shell runs (for example, the sub-script), whereas shell variables cannot be accessed in the commands that you run.</p>
<p>Assign an environment variable with the shell’s <code>export</code> command. For example, if you’d like to make the <code>$STUFF</code> shell variable into an environment variable, use the following:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STUFF=123</span><br><span class="line">export STUFF</span><br></pre></td></tr></table></figure></p>
<p><code>PATH</code> is a special environment variable that contains the <code>command path</code> (or path for short). A command path is a list of system directories that the shell searches when trying to locate a command.</p>
<p>resource:<br><em>Learning the vi and Vim Editorstm</em></p>
<p>Some <code>kill process</code> ways.There are many types of signals. The default is <code>TERM</code>, or terminate.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kill -STOP pid</span><br><span class="line">kill -CONT pid</span><br><span class="line">kill -KILL pid  # the same as kill -9 pid</span><br></pre></td></tr></table></figure></p>
<p>To see if you’ve accidentally suspended any processes on your current terminal, run the <code>jobs</code> command.</p>
<p>You can detach a process from the shell and put it in the “background” with the ampersand <code>&amp;</code>. The best way to make sure that a background process doesn’t bother you is to redirect its output (and possibly input).</p>
<p>Some executable files have an <code>s</code> in the <code>owner permissions</code> listing instead of an x. This indicates that the executable is <code>setuid</code>, meaning that when you execute the program, it runs as though the file owner is the user instead of you. Many programs use this <code>setuid</code> bit to run as root in order to get the privileges they need to change system files. One example is the <code>passwd</code> program, which needs to change the <code>/etc/passwd</code> file.</p>
<p>Directories also have permissions. You can list the contents of a directory if it’s readable, but you can only access a file in a directory if the directory is <code>executable</code>. (One common mistake people make when setting the permissions of directories is to accidentally remove the execute permission when using absolute modes.)</p>
<p>You can specify a set of default permissions with the <code>umask (user file-creation mode mask)</code>shell command, which applies a predefined set of permissions to any new file you create. In general, use <code>umask 022</code> if you want everyone to be able to see all of the files and directories that you create, and use <code>umask 077</code> if you don’t. (You’ll need to put the umask command with the desired mode in one of your startup files to make your new default permissions apply to later sessions).</p>
<blockquote>
<p>How to calculate the <code>umask</code>?</p>
<p>For directories, the base permissions are (rwxrwxrwx) <code>0777</code> and for files they are <code>0666</code> (rw-rw-rw).</p>
<p>You can simply subtract the umask from the base permissions to determine the final permission for file as follows:<br>666 – 022 = 644<br>subtract to get permissions of new file (666-022) : 644 (rw-r–r–)</p>
<p>You can simply subtract the umask from the base permissions to determine the final permission for directory as follows:<br>777 – 022 = 755<br>Subtract to get permissions of new directory (777-022) : 755 (rwxr-xr-x)</p>
</blockquote>
<p>Another compression program in Unix is <code>bzip2</code>, whose compressed files end with <code>.bz2</code>. While marginally slower than gzip, bzip2 often compacts text files a little more, and it is therefore increasingly popular in the distribution of source code. </p>
<p>The <code>bzip2</code> compression/decompression option for tar is <code>j</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar jcvf xx.bz2 file...</span><br><span class="line">tar jxvf xx.bz2</span><br></pre></td></tr></table></figure></p>
<h4 id="Linux-Directory-Hierarchy-Essentials"><a href="#Linux-Directory-Hierarchy-Essentials" class="headerlink" title="Linux Directory Hierarchy Essentials"></a>Linux Directory Hierarchy Essentials</h4><p>Simplified overview of the hierarchy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">                                                  +---------+</span><br><span class="line">                                                  |   /     |</span><br><span class="line">                                                  +-----+---+</span><br><span class="line">                                                        |</span><br><span class="line">    +-------------+-------------+-----------+----------------------+-----------+-----------+----------+</span><br><span class="line">    |             |             |           |           |          |           |           |          |</span><br><span class="line">    |             |             |           |           |          |           |           |          |</span><br><span class="line">    |             |             |           |           |          |           |           |          |</span><br><span class="line">    v             v             v           v           v          v           v           v          v</span><br><span class="line">+---+----+    +---+----+   +----+---+  +----+---+  +----+---+  +---+---+  +----+---+  +----+----+ +---------+</span><br><span class="line">|  /bin  |    |  /dev  |   |  /etc  |  |   /usr |  | /home  |  | /lib  |  |  /sbin |  |   /tmp  | |  /var   |</span><br><span class="line">+--------+    +--------+   +--------+  +----+---+  +--------+  +-------+  +--------+  +---------+ +----+----+</span><br><span class="line">                                            |                                                          |</span><br><span class="line">                                            |                                                     +----+-----+</span><br><span class="line">                                            |                                                     |          |</span><br><span class="line">              +---------+----------+--------------------+----------+                              |          |</span><br><span class="line">              |         |          |        |           |          |                              |          |</span><br><span class="line">              v         v          v        v           v          v                              v          v</span><br><span class="line">         +----+--+  +---+--+  +----+---+  +-+----+  +---+---+  +---+---+                     +----+---+  +---+----+</span><br><span class="line">         | bin/  |  | man/ |  |  lib/  |  |local/|  | sbin/ |  | share/|                     | log/   |  |  /tmp  |</span><br><span class="line">         +-------+  +------+  +--------+  +------+  +-------+  +-------+                     +--------+  +--------+</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><code>/bin</code> Contains ready-to-run programs (also known as an executables), including most of the basic Unix commands such as ls and cp. Most of the programs in /bin are in binary format, having been created by a C compiler, but some are shell scripts in modern systems.</p>
</li>
<li><p><code>/dev</code> Contains device files.</p>
</li>
<li><p><code>/etc</code> This core system configuration directory contains the user password, boot, device, networking, and other setup files. Many items in /etc are specific to the machine’s hardware. </p>
</li>
<li><p><code>/home</code> Holds personal directories for regular users. </p>
</li>
<li><p><code>/lib</code> An abbreviation for library, this directory holds library files containing code that executables can use.</p>
</li>
<li><p><code>/proc</code> Provides system statistics through a browsable directory-and-file interface. The <code>/proc</code> directory contains information about currently running processes as well as some kernel parameters.</p>
</li>
<li><p><code>/sys</code> This directory is similar to /proc in that it provides a device and system interface.</p>
</li>
<li><p><code>/sbin</code> The place for system executables. Programs in /sbin directories relate to system management.</p>
</li>
<li><p><code>/tmp</code> A storage area for smaller, temporary files that you don’t care much about. If something is extremely important, don’t put it in /tmp because most distributions clear /tmp when the machine boots and some even remove its old files periodically. Also, don’t let /tmp fill up with garbage because its space is usually shared with something critical  </p>
</li>
<li><p><code>/usr</code> Although pronounced “user,” this subdirectory has no user files. Instead, it contains a large directory hierarchy, including the bulk of the Linux system. Many of the directory names in /usr are the same as those in the root directory (like /usr/bin and /usr/lib), and they hold the same type of files. (The reason that the root directory does not contain the complete system is primarily historic—in the past, it was to keep space requirements low for the root.)</p>
</li>
<li><p><code>/var</code> The variable subdirectory, where programs record runtime information. System logging, user tracking, caches, and other files that system programs create and manage are here.</p>
</li>
<li><p><code>/boot</code> Contains kernel boot loader files. These files pertain only to the very first stage of the Linux startup procedure.</p>
</li>
<li><p><code>/media</code> A base attachment point for removable media such as flash drives that is found in many distributions.</p>
</li>
<li><p><code>/opt</code> This may contain additional third-party software. </p>
</li>
</ul>
<h4 id="Kernel-Location"><a href="#Kernel-Location" class="headerlink" title="Kernel Location"></a>Kernel Location</h4><p>On Linux systems, the kernel is normally in <code>/vmlinuz</code> or <code>/boot/vmlinuz</code>. A boot loader loads this file into memory and sets it in motion when the system boots.</p>
<p>Once the boot loader runs and sets the kernel in motion, the main kernel file is no longer used by the running system. However, you’ll find many modules that the kernel can load and unload on demand during the course of normal system operation. Called loadable kernel modules, they are located under <code>/lib/modules</code>.</p>
<h3 id="Chapter-3-Devices"><a href="#Chapter-3-Devices" class="headerlink" title="Chapter 3. Devices"></a>Chapter 3. Devices</h3><p>It’s important to understand how the kernel interacts with user space when presented with new devices. The <code>udev</code> system enables user-space programs to automatically configure and use new devices. </p>
<blockquote>
<p><code>udev</code> (userspace /dev) is a device manager for the Linux kernel. As the successor of devfsd and hotplug, udev primarily manages device nodes in the /dev directory.</p>
</blockquote>
<h4 id="Device-Files"><a href="#Device-Files" class="headerlink" title="Device Files"></a>Device Files</h4><p>It is easy to manipulate most devices on a Unix system because the kernel presents many of the device I/O interfaces to user processes as <strong>files</strong>. These device files are sometimes called <code>device nodes</code>. Not only can a programmer use regular file operations to work with a device, but some devices are also accessible to standard programs like <code>cat</code>. However, not all devices or device capabilities are accessible with standard file I/O.</p>
<p>Device files are in the <code>/dev</code> directory, and running <code>ls /dev</code> reveals more than a few files in <code>/dev</code>.</p>
<p>if run<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br><span class="line">brw-rw----     1 root disk 8, 1 Sep  6 08:37 sda1</span><br><span class="line">crw-rw-rw-     1 root root 1, 3 Sep  6 08:37 null</span><br><span class="line">prw-r--r--     1 root root    0 Mar  3 19:17 fdata</span><br><span class="line">srw-rw-rw-     1 root root    0 Dec 18 07:43 log</span><br></pre></td></tr></table></figure></p>
<p>if the first char in file mode is <code>b</code>, <code>c</code>, <code>p</code>, or <code>s</code>, the file is a device. These letters stand for block, character, pipe, and socket, respectively.</p>
<p>The numbers before the dates in the first two lines are the <code>major</code> and <code>minor</code> device numbers that help the kernel identify the device. Similar devices usually have the same major number.</p>
<h5 id="Block-device"><a href="#Block-device" class="headerlink" title="Block device"></a>Block device</h5><p>Programs access data from a block device in fixed chunks. The sad1 in the preceding example is a disk device, a type of block device.</p>
<h5 id="Character-device"><a href="#Character-device" class="headerlink" title="Character device"></a>Character device</h5><p>Character devices work with data streams. Printers directly attached to your computer are represented by character devices. It’s important to note that during character device interaction, the kernel cannot back up and reexamine the data stream after it has passed data to a device or process.</p>
<h5 id="Pipe-device"><a href="#Pipe-device" class="headerlink" title="Pipe device"></a>Pipe device</h5><p>Named pipes are like character devices, with another process at the other end of the I/O stream instead of a kernel driver.</p>
<h4 id="Socket-device"><a href="#Socket-device" class="headerlink" title="Socket device"></a>Socket device</h4><p>Sockets are special-purpose interfaces that are frequently used for interprocess communication. </p>
<blockquote>
<p>Not all devices have device files because the block and character device I/O interfaces are not appropriate in all cases. For example, <code>network interfaces</code> don’t have device files. It is theoretically possible to interact with a network interface using a single character device, but because it would be exceptionally difficult, the kernel uses other I/O interfaces.</p>
</blockquote>
<h4 id="The-sysfs-Device-Path"><a href="#The-sysfs-Device-Path" class="headerlink" title="The sysfs Device Path"></a>The sysfs Device Path</h4><p>To provide a uniform view for attached devices based on their actual hardware attributes, the Linux kernel offers the <code>sysfs</code> interface through a system of files and directories. The base path for devices is <code>/sys/devices</code> (this is a real directory!).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ls -ltr /sys/devices/</span><br><span class="line"></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 21 root root 0 Apr 25 23:18 virtual</span><br><span class="line">drwxr-xr-x  3 root root 0 Apr 25 23:18 tracepoint</span><br><span class="line">drwxr-xr-x 10 root root 0 Apr 25 23:18 system</span><br><span class="line">drwxr-xr-x  3 root root 0 Apr 25 23:18 software</span><br><span class="line">drwxr-xr-x  8 root root 0 Apr 25 23:18 pnp0</span><br><span class="line">drwxr-xr-x  9 root root 0 Apr 25 23:18 platform</span><br><span class="line">drwxr-xr-x 15 root root 0 Apr 25 23:18 pci0000:00</span><br><span class="line">drwxr-xr-x  5 root root 0 Apr 25 23:18 msr</span><br><span class="line">drwxr-xr-x  6 root root 0 Apr 25 23:18 LNXSYSTM:00</span><br><span class="line">drwxr-xr-x  3 root root 0 Apr 25 23:18 breakpoint</span><br></pre></td></tr></table></figure></p>
<p>The <code>/dev</code> file is there so that user processes can use the device, whereas the <code>/sys/devices</code> path is used to view information and manage the device. In <code>/dev</code> you can run:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">udevadm info --query=all --name=/dev/null</span><br><span class="line"></span><br><span class="line">P: /devices/virtual/mem/null</span><br><span class="line">N: null</span><br><span class="line">E: DEVMODE=0666</span><br><span class="line">E: DEVNAME=/dev/null</span><br><span class="line">E: DEVPATH=/devices/virtual/mem/null</span><br><span class="line">E: MAJOR=1</span><br><span class="line">E: MINOR=3</span><br><span class="line">E: SUBSYSTEM=mem</span><br></pre></td></tr></table></figure></p>
<p>this command will show the sysfs location <code>/devices/virtual/mem/null</code></p>
<h4 id="dd-and-Devices"><a href="#dd-and-Devices" class="headerlink" title="dd and Devices"></a>dd and Devices</h4><p>The program <code>dd</code> is extremely useful when working with block and character devices. This program’s sole function is to read from an input file or stream and write to an output file or stream, possibly doing some encoding conversion on the way.</p>
<p>I am not using it.</p>
<h4 id="Device-Name-Summary"><a href="#Device-Name-Summary" class="headerlink" title="Device Name Summary"></a>Device Name Summary</h4><p>Not necessarily as described below, may be some variations:</p>
<ul>
<li>Hard Disks: /dev/sd*</li>
</ul>
<p>Most hard disks attached to current Linux systems correspond to device names with an <code>sd</code> prefix, such as <code>/dev/sda</code>, <code>/dev/sdb</code>, and so on. These devices represent entire disks; the kernel makes separate device files, such as <code>/dev/sda1</code> and <code>/dev/sda2</code>, for the partitions on a disk.</p>
<blockquote>
<p>The <code>sd</code> portion of the name stands for SCSI disk.</p>
</blockquote>
<p>Linux assigns devices to device files in the <strong>order</strong> in which its drivers encounter devices. This may cause problem when you remove one disk and insert another, because the device name changed for old disk. Most modern Linux systems use the Universally Unique Identifier (<code>UUID</code>) for persistent disk device access.</p>
<ul>
<li>CD and DVD Drives: /dev/sr*</li>
</ul>
<p>Linux recognizes most optical storage drives as the SCSI devices /dev/sr0, /dev/sr1, and so on. </p>
<ul>
<li><p>PATA Hard Disks: /dev/hd*</p>
</li>
<li><p>Terminals: /dev/tty<em>, /dev/pts/</em>, and /dev/tty</p>
</li>
</ul>
<p>Terminals are devices for moving characters between a user process and an I/O device, usually for text output to a terminal screen. </p>
<p><code>Pseudoterminal</code> devices are emulated terminals that understand the I/O features of real terminals. </p>
<p>Two common terminal devices are <code>/dev/tty1</code> (the first virtual console) and <code>/dev/pts/0</code> (the first pseudoterminal device). The <code>/dev/tty</code> device is the controlling terminal of the current process.</p>
<blockquote>
<p>teletypewriter, <code>tty</code> in shorthand</p>
</blockquote>
<p>I am always confused, at least you need to know <strong>shell</strong> is the command line interpreter!<br><a href="https://askubuntu.com/questions/506510/what-is-the-difference-between-terminal-console-shell-and-command-line" target="_blank" rel="noopener">What is the difference between Terminal, Console, Shell, and Command Line?</a></p>
<p>Linux has two primary display modes: <code>text mode</code> and an <code>X Window System server</code> (graphics mode, usually via a display manager). Although Linux systems traditionally booted in text mode, most distributions now use kernel parameters and interim graphical display mechanisms to completely hide text mode as the system is booting. In such cases, the system switches over to full graphics mode near the end of the boot process.</p>
<p>OK, skip rest of the content in Chapter 3.</p>
<h3 id="Chapter-4-Disks-and-Filesystems"><a href="#Chapter-4-Disks-and-Filesystems" class="headerlink" title="Chapter 4. Disks and Filesystems"></a>Chapter 4. Disks and Filesystems</h3><p>Schematic of a typical Linux disk:</p>
<p><img src="https://drive.google.com/uc?id=1e0ziORmoEx6zPk6J6qEid26aWl-zw21G" alt=""></p>
<p><code>Partitions</code> are subdivisions of the whole disk. On Linux, they’re denoted with a number after the whole block device, and therefore have device names such as <code>/dev/sda1</code> and <code>/dev/sdb3</code>.</p>
<p>Partitions are defined on a small area of the disk called a <code>partition table</code>.</p>
<p>The next layer after the partition is the <code>filesystem</code>, the database of files and directories that you’re accustomed to interacting with in user space.</p>
<p>To access data on a disk, the Linux kernel uses the system of layers like this:</p>
<p><img src="https://drive.google.com/uc?id=1Hy8vWUIBuo33oH976PNEkVzvAOzCuyKJ" alt=""></p>
<blockquote>
<p>Notice that you can work with the disk through the filesystem as well as directly through the disk devices.</p>
</blockquote>
<h4 id="Partitioning-Disk-Devices"><a href="#Partitioning-Disk-Devices" class="headerlink" title="Partitioning Disk Devices"></a>Partitioning Disk Devices</h4><blockquote>
<p>You can view RedHat <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/storage_administration_guide/ch-partitions" target="_blank" rel="noopener">Doc</a> for more information about partition</p>
</blockquote>
<p>Let’s view the partition table:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">parted -l</span><br><span class="line"></span><br><span class="line">Model: ATA WDC WD3200AAJS-2 (scsi)</span><br><span class="line">Disk /dev/sda: 320GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: msdos</span><br><span class="line"></span><br><span class="line">Number   Start   End    Size   Type      File system    Flags</span><br><span class="line"> 1       1049kB  316GB  316GB  primary   ext4           boot</span><br><span class="line"> 2       316GB   320GB  4235MB extended</span><br><span class="line"> 5       316GB   320GB  4235MB logical   linux-swap(v1)</span><br><span class="line"></span><br><span class="line">Model: FLASH Drive UT_USB20 (scsi)</span><br><span class="line">Disk /dev/sdf: 4041MB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number  Start   End     Size     File system  Name        Flags</span><br><span class="line"> 1      17.4kB  1000MB  1000MB                myfirst</span><br><span class="line"> 2      1000MB  4040MB  3040MB                mysecond</span><br></pre></td></tr></table></figure></p>
<p>There are 2 different partition tables: MBR (msdos) and GPT (gpt). The MBR table in this example contains primary, extended, and logical partitions. </p>
<h4 id="Changing-Partition-Tables"><a href="#Changing-Partition-Tables" class="headerlink" title="Changing Partition Tables"></a>Changing Partition Tables</h4><p>You can use <code>parted</code> command to change partition. Check <code>/proc/partitions</code> can get full partition information.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/partitions</span><br><span class="line"></span><br><span class="line">major minor  #blocks  name</span><br><span class="line"> 252        0  262144000 vda</span><br><span class="line"> 252        1    1048576 vda1</span><br><span class="line"> 252        2  260976640 vda2</span><br><span class="line"> 253        0  252706816 dm-0</span><br><span class="line"> 253        1    8257536 dm-1</span><br></pre></td></tr></table></figure></p>
<h4 id="Filesystems"><a href="#Filesystems" class="headerlink" title="Filesystems"></a>Filesystems</h4><p>The last link between the kernel and user space for disks is typically the file-system; this is what you’re accustomed to interacting with when you run commands such as <code>ls</code> and <code>cd</code>. As previously mentioned, the <strong>filesystem is a form of database</strong>; it supplies the structure to transform a simple block device into the sophisticated hierarchy of files and subdirectories that users can understand.</p>
<h5 id="Filesystem-Types"><a href="#Filesystem-Types" class="headerlink" title="Filesystem Types"></a>Filesystem Types</h5><ul>
<li>The <code>Fourth Extended filesystem (ext4)</code> is the current iteration of a line of filesystems native to Linux. The <code>Second Extended filesystem (ext2)</code> was a longtime default for Linux systems inspired by traditional Unix filesystems such as the Unix File System (UFS) and the Fast File System (FFS). The <code>Third Extended filesystem (ext3)</code> added a journal feature (a small cache outside the normal filesystem data structure) to enhance data integrity and hasten booting. The ext4 filesystem is an incremental improvement with support for larger files than ext2 or ext3 support and a greater number of subdirectories.</li>
</ul>
<h5 id="Create-a-Filesystems"><a href="#Create-a-Filesystems" class="headerlink" title="Create a Filesystems"></a>Create a Filesystems</h5><p>Once you’re done with the partitioning process, you’re ready to create filesystems. As with partitioning, you’ll do this in user space because a user-space process can directly access and manipulate a block device. </p>
<p>For example, you can create an ext4 partition on /dev/sdf2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t ext4 /dev/sdf2</span><br></pre></td></tr></table></figure></p>
<p>Filesystem creation is a task that you should only need to perform after adding a new disk or repartitioning an old one. You should create a filesystem just once for each new partition that has no preexisting data (or that has data that you want to remove). Creating a new filesystem on top of an existing filesystem will effectively destroy the old data.</p>
<p>It turns out that mkfs is only a frontend for a series of filesystem creation programs:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ls -l /sbin/mkfs.*</span><br><span class="line"></span><br><span class="line">-rwxr-xr-x. 1 root root 375240 Mar  7  2017 /sbin/mkfs.btrfs</span><br><span class="line">-rwxr-xr-x  1 root root  37080 Jul 12  2018 /sbin/mkfs.cramfs</span><br><span class="line">-rwxr-xr-x  4 root root  96384 Apr 10  2018 /sbin/mkfs.ext2</span><br><span class="line">-rwxr-xr-x  4 root root  96384 Apr 10  2018 /sbin/mkfs.ext3</span><br><span class="line">-rwxr-xr-x  4 root root  96384 Apr 10  2018 /sbin/mkfs.ext4</span><br><span class="line">-rwxr-xr-x  1 root root  37184 Jul 12  2018 /sbin/mkfs.minix</span><br><span class="line">-rwxr-xr-x. 1 root root 368504 Feb 27  2018 /sbin/mkfs.xfs</span><br></pre></td></tr></table></figure></p>
<h5 id="Mounting-a-Filesystem"><a href="#Mounting-a-Filesystem" class="headerlink" title="Mounting a Filesystem"></a>Mounting a Filesystem</h5><p>On Unix, the process of attaching a filesystem is called <code>mounting</code>. When the system boots, the kernel reads some configuration data and mounts root (/) based on the configuration data.</p>
<p>When mounting a filesystem, the common terminology is <em>mount a device on a mount point.</em></p>
<p>To see current system mount status:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mount </span><br><span class="line">...</span><br><span class="line">cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br><span class="line">/dev/mapper/rhel-root on / type xfs (rw,relatime,attr2,inode64,noquota)</span><br><span class="line">mqueue on /dev/mqueue type mqueue (rw,relatime)</span><br><span class="line">hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime)</span><br><span class="line">/dev/vda1 on /boot type xfs (rw,relatime,attr2,inode64,noquota)</span><br><span class="line">tmpfs on /run/user/0 type tmpfs (rw,nosuid,nodev,relatime,size=800956k,mode=700)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>There are 3 key fields:</p>
<ul>
<li>The filesystem’s device, such as a disk partition; where the actual file-system data resides</li>
<li>The filesystem type</li>
<li>The mount point—that is, the place in the current system’s directory hierarchy where the filesystem will be attached. </li>
</ul>
<p>For example, to mount the Fourth Extended filesystem /dev/sdf2 on /home/extra, use this command:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t ext4 /dev/sdf2 /home/extra</span><br></pre></td></tr></table></figure></p>
<p>To unmount (detach) a filesystem, use the umount command:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount mountpoint</span><br></pre></td></tr></table></figure></p>
<h5 id="Filesystem-UUID"><a href="#Filesystem-UUID" class="headerlink" title="Filesystem UUID"></a>Filesystem UUID</h5><p>You can identify and mount filesystems by their <code>Universally Unique Identifier (UUID)</code>, a software standard. The UUID is a type of serial number, and each one should be different.</p>
<p>For example, if you know the UUID of /dev/sdf2 is a9011c2b-1c03-4288-b3fe-8ba961ab0898, so you can mount it as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount UUID=a9011c2b-1c03-4288-b3fe-8ba961ab0898 /home/extra</span><br></pre></td></tr></table></figure></p>
<p>Here no <code>-t  ext4</code> option, because mount know that.</p>
<p>To view a list of devices and the corresponding filesystems and UUIDs on your system, use the blkid (block ID) program:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">blkid</span><br><span class="line"></span><br><span class="line">/dev/sdf2: UUID=&quot;a9011c2b-1c03-4288-b3fe-8ba961ab0898&quot; TYPE=&quot;ext4&quot;</span><br><span class="line">/dev/sda1: UUID=&quot;70ccd6e7-6ae6-44f6-812c-51aab8036d29&quot; TYPE=&quot;ext4&quot;</span><br><span class="line">/dev/sda5: UUID=&quot;592dcfd1-58da-4769-9ea8-5f412a896980&quot; TYPE=&quot;swap&quot;</span><br><span class="line">/dev/sde1: SEC_TYPE=&quot;msdos&quot; UUID=&quot;3762-6138&quot; TYPE=&quot;vfat&quot;</span><br></pre></td></tr></table></figure></p>
<p>For one thing, they’re the preferred way to automatically mount filesystems in <code>/etc/fstab</code> at boot time.</p>
<h5 id="Disk-Buffering-Caching-and-Filesystems"><a href="#Disk-Buffering-Caching-and-Filesystems" class="headerlink" title="Disk Buffering, Caching, and Filesystems"></a>Disk Buffering, Caching, and Filesystems</h5><p>Linux, like other versions of Unix, buffers writes to the disk. This means that the kernel usually doesn’t immediately write changes to filesystems when processes request changes. <strong>Instead it stores the changes in RAM until the kernel can conveniently make the actual change to the disk</strong>. This buffering system is transparent to the user and improves performance.</p>
<blockquote>
<p>This is the reason why before we remove the USB, we need to unmount it in case of data lose.</p>
</blockquote>
<p>When you unmount a filesystem with umount, the kernel automatically synchronizes with the disk. At any other time, you can force the kernel to write the changes in its buffer to the disk by running the <code>sync</code> command.</p>
<h5 id="The-etc-fstab-Filesystem-Table"><a href="#The-etc-fstab-Filesystem-Table" class="headerlink" title="The /etc/fstab Filesystem Table"></a>The /etc/fstab Filesystem Table</h5><p>I encounter this when write <code>/etc/fstab</code> file with NFS when developing k8s.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/dev/mapper/rhel-root   /                       xfs     defaults        0 0</span><br><span class="line">UUID=a44461e9-e1d7-45fd-a387-255fafd14746 /boot                   xfs     defaults        0 0</span><br><span class="line">/dev/mapper/rhel-swap   swap                    swap    defaults        0 0</span><br><span class="line">halos1.fyre.ibm.com:/data /mnt nfs defaults,timeo=10,retrans=3,rsize=1048576,wsize=1048576 0 0</span><br></pre></td></tr></table></figure></p>
<p>To mount filesystems at boot time and take the drudgery out of the mount command, Linux systems keep a permanent list of filesystems and options in <code>/etc/fstab</code>.</p>
<ul>
<li><p><code>The device or UUID</code>. Most current Linux systems no longer use the device in /etc/fstab, preferring the UUID. </p>
</li>
<li><p><code>The mount point</code>. Indicates where to attach the filesystem.</p>
</li>
<li><p><code>The filesystem type</code>.</p>
</li>
<li><p><code>Options</code>. Use long mount options separated by commas.</p>
</li>
<li><p><code>Backup information for use by the dump command</code>. You should always use a 0 in this field.</p>
</li>
<li><p><code>The filesystem integrity test order.</code> To ensure that fsck always runs on the root first, always set this to 1 for the root filesystem and 2 for any other filesystems on a hard disk. Use <code>0</code> to disable the bootup check for everything else, including CD-ROM drives, swap, and the /proc file-system</p>
</li>
</ul>
<p>You can also try to mount all entries at once in /etc/fstab that do not contain the noauto option with this command:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -a</span><br></pre></td></tr></table></figure></p>
<p>Let’s see some commonly use options:</p>
<ul>
<li><p><code>defaults</code>. This uses the mount defaults: read-write mode, enable device files, executables, the setuid bit, and so on. Use this when you don’t want to give the filesystem any special options but you do want to fill all fields in /etc/fstab.</p>
</li>
<li><p><code>noauto</code>. This option tells a mount -a command to ignore the entry. </p>
</li>
</ul>
<h5 id="Filesystem-Capacity"><a href="#Filesystem-Capacity" class="headerlink" title="Filesystem Capacity"></a>Filesystem Capacity</h5><p>To view the size and utilization of your currently mounted filesystems, use the <code>df</code> command.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df -BM</span><br><span class="line"></span><br><span class="line">Filesystem                1M-blocks   Used Available Use% Mounted on</span><br><span class="line">/dev/mapper/rhel-root       245640M 75636M   170005M  31% /</span><br><span class="line">devtmpfs                      7931M     0M     7931M   0% /dev</span><br><span class="line">tmpfs                         7943M     0M     7943M   0% /dev/shm</span><br><span class="line">tmpfs                         7943M   835M     7109M  11% /run</span><br><span class="line">tmpfs                         7943M     0M     7943M   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1                     1014M   183M      832M  19% /boot</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h5 id="Checking-and-Repairing-Filesystems"><a href="#Checking-and-Repairing-Filesystems" class="headerlink" title="Checking and Repairing Filesystems"></a>Checking and Repairing Filesystems</h5><p>Filesystem errors are usually due to a user shutting down the system in a rude way (for example, by pulling out the power cord). In such cases, the filesystem cache in memory may not match the data on the disk, and the system also may be in the process of altering the filesystem when you happen to give the computer a kick. Although a new generation of filesystems supports journals to make filesystem corruption far less common, you should always shut the system down properly. And regardless of the filesystem in use, filesystem checks are still necessary every now and to maintain sanity.</p>
<p>The tool to check a filesystem is <code>fsck</code>.</p>
<p>In the worst cases, you can try:</p>
<ul>
<li><p>You can try to extract the entire filesystem image from the disk with <code>dd</code> and transfer it to a partition on another disk of the same size.</p>
</li>
<li><p>You can try to patch the filesystem as much as possible, mount it in read-only mode, and salvage what you can.</p>
</li>
<li><p>You can try <code>debugfs</code>.</p>
</li>
</ul>
<h5 id="Special-Purpose-Filesystems"><a href="#Special-Purpose-Filesystems" class="headerlink" title="Special-Purpose Filesystems"></a>Special-Purpose Filesystems</h5><p>Not all filesystems represent storage on physical media. Specifically, most versions of Unix have filesystems that serve as system interfaces. That is, rather than serving only as a means to store data on a device, a filesystem can represent system information such as process IDs and kernel diagnostics.</p>
<p>The special filesystem types in common use on Linux include the following:</p>
<ul>
<li><p><code>proc</code>. Mounted on /proc. The name proc is actually an abbreviation for process. Each numbered directory inside /proc is actually the process ID of a current process on the system; the files in those directories represent various aspects of the processes. The file /proc/self represents the current process. </p>
</li>
<li><p><code>sysfs</code>. Mounted on /sys.</p>
</li>
<li><p><code>tmpfs</code>. Mounted on /run and other locations. With tmpfs, you can use your physical memory and swap space as temporary storage, stored in volatile memory instead of a persistent storage device.</p>
</li>
</ul>
<h4 id="Swap-Space"><a href="#Swap-Space" class="headerlink" title="Swap Space"></a>Swap Space</h4><p>Not every partition on a disk contains a filesystem. It’s also possible to augment the RAM on a machine with disk space. The disk area used to store memory pages is called <code>swap space</code> (or just swap for short).</p>
<p>you can use <code>free</code> command to see the swap usage:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">free -m</span><br><span class="line"></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:          32010       10894        3992        1605       17123       18811</span><br><span class="line">Swap:          8063          64        7999</span><br></pre></td></tr></table></figure></p>
<p>you can use a disk partition and a regular file as swap space, for disk:</p>
<ol>
<li>Ensure partition is empty</li>
<li>Run <code>mkswap dev</code>, dev is the partition device</li>
<li>Execute <code>swapon dev</code> to register the space with the kernel.</li>
<li>Register in <code>/etc/fstab</code> file</li>
</ol>
<p>Use these commands to create an empty file, initialize it as swap, and add it to the swap pool:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=swap_file bs=1024k count=num_mb</span><br><span class="line">mkswap swap_file</span><br><span class="line">swapon swap_file</span><br></pre></td></tr></table></figure></p>
<p>Here, <code>swap_file</code> is the name of the new swap file, and <code>num_mb</code> is the desired size, in megabytes.</p>
<p>To remove a swap partition or file from the kernel’s active pool, use the <code>swapoff</code> command.</p>
<p><strong>Note</strong> some administrators configure certain systems with <strong>no</strong> swap space at all. For example, high-performance network servers should never dip into swap space and should avoid disk access if at all possible.</p>
<p>It’s dangerous to do this on a general-purpose machine. If a machine completely runs out of both real memory and swap space, the Linux kernel invokes the <code>out-of-memory (OOM)</code> killer to kill a process in order to free up some memory. You obviously don’t want this to happen to your desktop applications. On the other hand, high-performance servers include sophisticated monitoring and load-balancing systems to ensure that they never reach the danger zone.</p>
<h4 id="Looking-Forward-Disks-and-User-Space"><a href="#Looking-Forward-Disks-and-User-Space" class="headerlink" title="Looking Forward: Disks and User Space"></a>Looking Forward: Disks and User Space</h4><p>In disk-related components on a Unix system, the boundaries between user space and the kernel can be difficult to characterize. As you’ve seen, the kernel handles raw block I/O from the devices, and user-space tools can use the block I/O through device files. However, user space typically uses the block I/O only for initializing operations such as partitioning, file-system creation, and swap space creation.</p>
<p>In normal use, user space uses only the filesystem support that the kernel provides on top of the block I/O.</p>
<h3 id="Chapter-5-How-the-Linux-Kernel-Boots"><a href="#Chapter-5-How-the-Linux-Kernel-Boots" class="headerlink" title="Chapter 5. How the Linux Kernel Boots"></a>Chapter 5. How the Linux Kernel Boots</h3><p>You’ll learn how the kernel moves into memory up to the point where the first user process starts.</p>
<p><strong>A simplified view of the boot process looks like this:</strong></p>
<ol>
<li>The machine’s BIOS or boot firmware loads and runs a boot loader.</li>
<li>The boot loader finds the kernel image on disk, loads it into memory, and starts it.</li>
<li>The kernel initializes the devices and its drivers.</li>
<li>The kernel mounts the root filesystem.</li>
<li>The kernel starts a program called init with a process ID of 1. This point is the user space start.</li>
<li>init sets the rest of the system processes in motion.</li>
<li>At some point, init starts a process allowing you to log in, usually at the end or near the end of the boot.</li>
</ol>
<h4 id="Startup-Messages"><a href="#Startup-Messages" class="headerlink" title="Startup Messages"></a>Startup Messages</h4><p>There are two ways to view the kernel’s boot and runtime diagnostic messages:</p>
<ul>
<li><p>Look at the kernel system log file. You’ll often find this in <code>/var/log/ kern.log</code>, but depending on how your system is configured, it might also be lumped together with a lot of other system logs in <code>/var/log/messages</code> or elsewhere.</p>
</li>
<li><p>Use the <code>dmesg</code> command, but be sure to pipe the output to less because there will be much more than a screen’s worth. The <code>dmesg</code> command uses the kernel ring buffer, which is of limited size, but most newer kernels have a large enough buffer to hold boot messages for a long time.</p>
</li>
</ul>
<h4 id="Kernel-Initialization-and-Boot-Options"><a href="#Kernel-Initialization-and-Boot-Options" class="headerlink" title="Kernel Initialization and Boot Options"></a>Kernel Initialization and Boot Options</h4><p>Upon startup, the Linux kernel initializes in this general order:</p>
<ol>
<li>CPU inspection</li>
<li>Memory inspection</li>
<li>Device bus discovery</li>
<li>Device discovery</li>
<li>Auxiliary kernel subsystem setup (networking, and so on)</li>
<li>Root filesystem mount</li>
<li>User space start</li>
</ol>
<p>The following memory management messages are a good indication that the user-space handoff is about to happen because this is where the kernel protects its own memory from user-space processes:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[    0.972934] Freeing unused kernel memory: 1844k freed</span><br><span class="line">[    0.973411] Write protecting the kernel read-only data: 12288k</span><br><span class="line">[    0.975623] Freeing unused kernel memory: 832k freed</span><br><span class="line">[    0.977405] Freeing unused kernel memory: 676k freed</span><br></pre></td></tr></table></figure></p>
<h4 id="Kernel-Parameters"><a href="#Kernel-Parameters" class="headerlink" title="Kernel Parameters"></a>Kernel Parameters</h4><p>I just encountered an issue about kernel parameters for Db2… Let’s see.</p>
<p>When running the Linux kernel, the boot loader passes in a set of text-based <strong>kernel parameters</strong> that tell the kernel how it should start. The parameters specify many different types of behavior, such as the amount of diagnostic output the kernel should produce and device driver–specific options.</p>
<p>You can view the kernel parameters from your system’s boot by looking at the <code>/proc/cmdline</code> file:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOT_IMAGE=/vmlinuz-3.10.0-862.14.4.el7.x86_64 root=/dev/mapper/rhel-root ro crashkernel=auto rd.lvm.lv=rhel/root rd.lvm.lv=rhel/swap rhgb quiet elevator=noop LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure></p>
<p>The <code>root=/dev/mapper/rhel-root</code> is where root filesystem resides.</p>
<h4 id="Boot-Loader"><a href="#Boot-Loader" class="headerlink" title="Boot Loader"></a>Boot Loader</h4><p><a href="https://searchdatacenter.techtarget.com/definition/boot-loader-boot-manager" target="_blank" rel="noopener">Other boot loader intro</a></p>
<p>At the start of the boot process, before the kernel and init start, a boot loader starts the kernel. The task of a boot loader sounds simple: It loads the kernel into memory, and then starts the kernel with a set of kernel parameters.</p>
<p>Kernel and its parameters are usually somewhere on the root filesystem.</p>
<p>On PCs, boot loaders use the <code>Basic Input/Output System (BIOS)</code> or <code>Unified Extensible Firmware Interface (UEFI)</code> to access disks. Nearly all disk hardware has firmware that allows the BIOS to access attached storage hardware with <code>Linear Block Addressing (LBA)</code>. Although it exhibits poor performance, this mode of access does allow universal access to disks. Boot loaders are often the only programs to use the BIOS for disk access; the kernel uses its own high-performance drivers.</p>
<p>Most modern boot loaders can read partition tables and have built-in support for read-only access to filesystems. </p>
<h5 id="Boot-loader-tasks"><a href="#Boot-loader-tasks" class="headerlink" title="Boot loader tasks"></a>Boot loader tasks</h5><ol>
<li>Select among multiple kernels.</li>
<li>Switch between sets of kernel parameters.</li>
<li>Allow the user to manually override and edit kernel image names and parameters </li>
<li>Provide support for booting other operating systems.</li>
</ol>
<h5 id="Boot-loader-typres"><a href="#Boot-loader-typres" class="headerlink" title="Boot loader typres"></a>Boot loader typres</h5><ul>
<li>GRUB. A near-universal standard on Linux systems (mainly talks about this)</li>
<li>LILO. One of the first Linux boot loaders.</li>
<li>LOADLIN. Boots a kernel from MS-DOS</li>
</ul>
<h4 id="GRUB-Introduction"><a href="#GRUB-Introduction" class="headerlink" title="GRUB Introduction"></a>GRUB Introduction</h4><p>GRUB stands for Grand Unified Boot Loader. We’ll cover GRUB 2.</p>
<p>This section talks about GRUB menu and look into some boot options, actually, if you check <code>/boot</code> directory, you will see kernel image file and initial RAM filesystem:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">-rwxr-xr-x. 1 root root  6381872 Mar 21  2018 vmlinuz-3.10.0-862.el7.x86_64</span><br><span class="line">-rw-r--r--. 1 root root   304926 Mar 21  2018 symvers-3.10.0-862.el7.x86_64.gz</span><br><span class="line">drwx------. 5 root root       97 Oct  1  2018 grub2</span><br><span class="line">-rw-------  1 root root 21096334 Oct  1  2018 initramfs-3.10.0-862.9.1.el7.x86_64.img</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>Not interested in the rest of the content in this chapter.</p>
<h3 id="Chapter-6-How-User-Space-Starts"><a href="#Chapter-6-How-User-Space-Starts" class="headerlink" title="Chapter 6. How User Space Starts"></a>Chapter 6. How User Space Starts</h3><p>The point where the kernel starts its first user-space process, init, is significant—not just because that’s where the memory and CPU are finally ready for normal system operation, but because that’s where you can see how the rest of the system builds up as a whole. </p>
<p>User space is far more modular. It’s much easier to see what goes into the user space startup and operation.</p>
<p>User space starts in roughly this order:</p>
<ol>
<li>init</li>
<li>Essential low-level services such as udevd and syslogd</li>
<li>Network configuration</li>
<li>Mid- and high-level services (cron, printing, and so on)</li>
<li>Login prompts, GUIs, and other high-level applications</li>
</ol>
<h4 id="Introduction-to-init"><a href="#Introduction-to-init" class="headerlink" title="Introduction to init"></a>Introduction to init</h4><p><a href="https://en.wikipedia.org/wiki/Init" target="_blank" rel="noopener">wiki init</a></p>
<p>The init program is a <strong>user-space program</strong> like any other program on the Linux system, and you’ll find it in <code>/sbin</code> along with many of the other system binaries. Its main purpose is to start and stop the essential service processes on the system, but newer versions have more responsibilities.</p>
<p>In my vm <code>/sbin</code> directory:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx  1 root root          22 Oct  1  2018 init -&gt; ../lib/systemd/systemd</span><br></pre></td></tr></table></figure></p>
<p>There are three major implementations of init in Linux distributions:</p>
<ul>
<li><code>System V</code> init. A traditional sequenced init (Sys V, usually <em>pronounced “sys-five”</em>). Red Hat Enterprise Linux and several other distributions use this version.</li>
<li><code>systemd</code>. The emerging standard for init. Many distributions have moved to systemd, and most that have not yet done so are planning to move to it.</li>
<li><code>Upstart</code>. The init on Ubuntu installations. However, as of this writing, Ubuntu has also planned to migrate to systemd.</li>
</ul>
<p>There are many different implementations of init because <code>System V</code> init and other older versions relied on a sequence that performed only one startup task at a time. <code>systemd</code> and <code>Upstart</code> attempt to remedy the performance issue by allowing many services to start in parallel thereby speeding up the boot process. </p>
<h4 id="System-V-Runlevels"><a href="#System-V-Runlevels" class="headerlink" title="System V Runlevels"></a>System V Runlevels</h4><p><a href="https://en.wikipedia.org/wiki/Runlevel" target="_blank" rel="noopener">wiki Runlevel</a></p>
<p>At any given time on a Linux system, a certain base set of processes is running. In System V init, this state of the machine is called its <code>runlevel</code>, which is denoted by a number from 0 through 6. A system spends most of its time in a single runlevel, but when you shut the machine down, init switches to a different runlevel in order to terminate the system services in an orderly fashion and to tell the kernel to stop.</p>
<p>You can check your system’s runlevel with the <code>who -r</code> command:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">who -r</span><br><span class="line"></span><br><span class="line">run-level 3  2019-04-17 13:49</span><br></pre></td></tr></table></figure></p>
<p>Runlevels serve various purposes, but the most common one is to distinguish between system startup, shutdown, single-user mode, and console mode states.</p>
<p>But runlevels are becoming a thing of the past. Even though all three init versions in this book support them, systemd and Upstart consider runlevels obsolete as end states for the system. </p>
<h4 id="Identifying-Your-init"><a href="#Identifying-Your-init" class="headerlink" title="Identifying Your init"></a>Identifying Your init</h4><ul>
<li><p>If your system has /usr/lib/systemd and /etc/systemd directories, you have systemd.</p>
</li>
<li><p>If you have an /etc/init directory that contains several .conf files, you’re probably running Upstart </p>
</li>
<li><p>If neither of the above is true, but you have an /etc/inittab file, you’re probably running System V init.</p>
</li>
</ul>
<p><strong>Here I focus on systemd</strong></p>
<h4 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h4><p>The systemd init is one of the newest init implementations on Linux. In addition to handling the regular boot process, systemd aims to incorporate a number of standard Unix services such as cron and inetd. One of its most significant features is its ability to defer the start of services and operating system features until they are necessary.</p>
<p>Let’s outline what happens when systemd runs at boot time:</p>
<ol>
<li>systemd loads its configuration.</li>
<li>systemd determines its boot goal, which is usually named default.target.</li>
<li>systemd determines all of the dependencies of the default boot goal, dependencies of these dependencies, and so on.</li>
<li>systemd activates the dependencies and the boot goal.</li>
<li>After boot, systemd can react to system events (such as uevents) and activate additional components.</li>
</ol>
<h5 id="Units-and-Unit-Types"><a href="#Units-and-Unit-Types" class="headerlink" title="Units and Unit Types"></a>Units and Unit Types</h5><p>One of the most interesting things about <code>systemd</code> is that it does not just operate processes and services; it can also mount filesystems, monitor network sockets, run timers, and more. Each type of capability is called a <code>unit type</code>, and each specific capability is called a <code>unit</code>. When you turn on a unit, you activate it.</p>
<p>The default boot goal is usually a <code>target unit</code> that groups together a number of <code>service</code> and <code>mount</code> units as dependencies. </p>
<p><a href="https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files" target="_blank" rel="noopener">understand systemd unit and unit files</a></p>
<h5 id="systemd-Dependencies"><a href="#systemd-Dependencies" class="headerlink" title="systemd Dependencies"></a>systemd Dependencies</h5><p>To accommodate the need for flexibility and fault tolerance, systemd offers a myriad of dependency types and styles:</p>
<ul>
<li><p><code>Requires</code> Strict dependencies. When activating a unit with a Requires dependency unit, systemd attempts to activate the dependency unit. If the dependency unit fails, systemd deactivates the dependent unit.</p>
</li>
<li><p><code>Wants</code>. Dependencies for activation only. Upon activating a unit, systemd activates the unit’s Wants dependencies, but it doesn’t care if those dependencies fail.</p>
</li>
<li><p><code>Requisite</code>. Units that must already be active.</p>
</li>
<li><p><code>Conflicts</code>. Negative dependencies. When activating a unit with a Conflict dependency, systemd automatically deactivates the dependency if it is active.</p>
</li>
</ul>
<p>There are many other dependency syntax, like ordering, conditional, etc…</p>
<h5 id="systemd-Configuration"><a href="#systemd-Configuration" class="headerlink" title="systemd Configuration"></a>systemd Configuration</h5><p>The systemd configuration files are spread among many directories across the system, so you typically won’t find the files for all of the units on a system in one place.</p>
<p>That said, there are two main directories for systemd configuration: the system unit directory (globally configured, usually <code>/usr/lib/systemd/system</code>) and a system configuration directory (local definitions, usually <code>/etc/systemd/system</code>).</p>
<blockquote>
<p>Note: Avoid making changes to the system unit directory because your distribution will maintain it for you. Make your local changes to the system configuration directory.</p>
</blockquote>
<p>To see the system unit and configuration directories on your system, use the following commands:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config systemd --variable=systemdsystemunitdir</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config systemd --variable=systemdsystemconfdir</span><br></pre></td></tr></table></figure>
<p>Let’s see Unit files in <code>/usr/lib/systemd/system</code>, there is a sshd.service file:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=OpenSSH server daemon</span><br><span class="line">Documentation=man:sshd(8) man:sshd_config(5)</span><br><span class="line">After=network.target sshd-keygen.service</span><br><span class="line">Wants=sshd-keygen.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">EnvironmentFile=/etc/sysconfig/sshd</span><br><span class="line">ExecStart=/usr/sbin/sshd -D $OPTIONS</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=42s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p>
<p>The [Unit] section gives some details about the unit and contains description and dependency information. </p>
<p>You’ll find the details about the service in the [Service] section, including how to prepare, start, and reload the service. </p>
<p>During normal operation, systemd ignores the [Install] section. However, consider the case when sshd.service is disabled on your system and you would like to turn it on. When you enable a unit, systemd reads the [Install] section.</p>
<p>The [Install] section is usually responsible for the the .wants and .requires directories in the system configuration directory (<code>/etc/systemd/system</code>), see:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">basic.target.wants                                       getty.target.wants           remote-fs.target.wants</span><br><span class="line">default.target                                           local-fs.target.wants        sockets.target.wants</span><br><span class="line">default.target.wants                                     multi-user.target.wants      sysinit.target.wants</span><br><span class="line">dev-virtio\x2dports-org.qemu.guest_agent.0.device.wants  network-online.target.wants  system-update.target.wants</span><br></pre></td></tr></table></figure></p>
<p>the  $OPTIONS in unit file is the variable, also specifier is another variable-like feature often found in unit files, like %n and %H.</p>
<h4 id="systemd-Operation"><a href="#systemd-Operation" class="headerlink" title="systemd Operation"></a>systemd Operation</h4><p>You’ll interact with systemd primarily through the <code>systemctl</code> command, which allows you to activate and deactivate services, list status, reload the configuration, and much more.</p>
<p>List of active units:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">systemctl</span><br><span class="line"></span><br><span class="line">  UNIT                                           LOAD   ACTIVE SUB       DESCRIPTION</span><br><span class="line">...</span><br><span class="line">  sys-kernel-debug.mount                         loaded active mounted   Debug File System</span><br><span class="line">  var-lib-nfs-rpc_pipefs.mount                   loaded active mounted   RPC Pipe File System</span><br><span class="line">  brandbot.path                                  loaded active waiting   Flexible branding</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>List all units, includes inactives:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl --all</span><br></pre></td></tr></table></figure></p>
<p>Get status of a unit:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status sshd.service</span><br></pre></td></tr></table></figure></p>
<p>To activate, deactivate, and restart units, use the systemd <code>start</code>, <code>stop</code>, and <code>restart</code> commands. However, if you’ve changed a unit configuration file, you can tell systemd to reload the file in one of two ways:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl reload unit #Reloads just the configuration for unit.</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload #Reloads all unit configurations.</span><br></pre></td></tr></table></figure>
<h5 id="systemd-Process-Tracking-and-Synchronization"><a href="#systemd-Process-Tracking-and-Synchronization" class="headerlink" title="systemd Process Tracking and Synchronization"></a>systemd Process Tracking and Synchronization</h5><p>systemd wants a reasonable amount of information and control over every process that it starts. The main problem that it faces is that a service can start in different ways; it may fork new instances of itself or even daemonize and detach itself from the original process.</p>
<p>To minimize the work that a package developer or administrator needs to do in order to create a working unit file, systemd uses <code>control groups (cgroups)</code>, an optional Linux kernel feature that allows for finer tracking of a process hierarchy.</p>
<h5 id="systemd-On-Demand-and-Resource-Parallelized-Startup"><a href="#systemd-On-Demand-and-Resource-Parallelized-Startup" class="headerlink" title="systemd On-Demand and Resource-Parallelized Startup"></a>systemd On-Demand and Resource-Parallelized Startup</h5><p>One of systemd’s most significant features is its ability to delay a unit startup until it is absolutely needed. </p>
<h5 id="systemd-Auxiliary-Programs"><a href="#systemd-Auxiliary-Programs" class="headerlink" title="systemd Auxiliary Programs"></a>systemd Auxiliary Programs</h5><p>When starting out with systemd, you may notice the exceptionally large number of programs in <code>/lib/systemd</code>. These are primarily support programs for units. For example, <code>udevd</code> is part of systemd, and you’ll find it there as <code>systemd-udevd</code>. Another, the <code>systemd-fsck</code> program, works as a middleman between systemd and fsck.</p>
<h4 id="Shutting-Down-Your-System"><a href="#Shutting-Down-Your-System" class="headerlink" title="Shutting Down Your System"></a>Shutting Down Your System</h4><p>init controls how the system shuts down and reboots. The commands to shut down the system are the same regardless of which version of init you run. The proper way to shut down a Linux machine is to use the <code>shutdown</code> command.</p>
<p>to shutdown machine immediately:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now</span><br></pre></td></tr></table></figure></p>
<p>to reboot the machine now:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure></p>
<p>When system shutdown time finally arrives, shutdown tells init to begin the shutdown process. On systemd, it means activating the shutdown units; and on System V init, it means changing the runlevel to 0 or 6.</p>
<h4 id="The-Initial-RAM-Filesystem"><a href="#The-Initial-RAM-Filesystem" class="headerlink" title="The Initial RAM Filesystem"></a>The Initial RAM Filesystem</h4><p>The <code>initramfs</code> is in <code>/boot</code> directory.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ls -ltr | grep init</span><br><span class="line"></span><br><span class="line">-rw-------. 1 root root 55376391 Apr 13  2018 initramfs-0-rescue-e57cfe9136e9430587366e04f14195e1.img</span><br><span class="line">-rw-------. 1 root root 13131435 Apr 13  2018 initramfs-3.10.0-862.el7.x86_64kdump.img</span><br><span class="line">-rw-------  1 root root 21098233 Jul 23  2018 initramfs-3.10.0-862.el7.x86_64.img</span><br><span class="line">-rw-------  1 root root 21134858 Oct  1  2018 initramfs-3.10.0-862.14.4.el7.x86_64.img</span><br><span class="line">-rw-------  1 root root 21096334 Oct  1  2018 initramfs-3.10.0-862.9.1.el7.x86_64.img</span><br></pre></td></tr></table></figure></p>
<p>The problem stems from the availability of many different kinds of storage hardware. Remember, the Linux kernel does not talk to the PC BIOS or EFI interfaces to get data from disks, so in order to mount its root file-system, it needs driver support for the underlying storage mechanism.</p>
<p>The workaround is to gather a small collection of kernel driver modules along with a few other utilities into an archive. The boot loader loads this archive into memory before running the kernel.</p>
<h3 id="Chapter-7-System-Configuration"><a href="#Chapter-7-System-Configuration" class="headerlink" title="Chapter 7. System Configuration"></a>Chapter 7. System Configuration</h3>
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/linux/" rel="tag"># linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/13/linux-soft-link/" rel="next" title="Symbolic Link Operations">
                <i class="fa fa-chevron-left"></i> Symbolic Link Operations
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/27/music-渴望光荣/" rel="prev" title="渴望光荣">
                渴望光荣 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/cuishao.png" alt="海胆阶段">
            
              <p class="site-author-name" itemprop="name">海胆阶段</p>
              <p class="site-description motion-element" itemprop="description">骐骥一跃，不能十步；驽马十驾，功在不舍</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">42</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">36</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter1-The-Big-picture"><span class="nav-number">1.</span> <span class="nav-text">Chapter1. The Big picture</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Hardware"><span class="nav-number">1.1.</span> <span class="nav-text">Hardware</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kernel"><span class="nav-number">1.2.</span> <span class="nav-text">Kernel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#User-Space"><span class="nav-number">1.3.</span> <span class="nav-text">User Space</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Users"><span class="nav-number">1.4.</span> <span class="nav-text">Users</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-2-Basic-Commands-and-Directory-Hierarchy"><span class="nav-number">2.</span> <span class="nav-text">Chapter 2. Basic Commands and Directory Hierarchy</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux-Directory-Hierarchy-Essentials"><span class="nav-number">2.1.</span> <span class="nav-text">Linux Directory Hierarchy Essentials</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kernel-Location"><span class="nav-number">2.2.</span> <span class="nav-text">Kernel Location</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-3-Devices"><span class="nav-number">3.</span> <span class="nav-text">Chapter 3. Devices</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Device-Files"><span class="nav-number">3.1.</span> <span class="nav-text">Device Files</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Block-device"><span class="nav-number">3.1.1.</span> <span class="nav-text">Block device</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Character-device"><span class="nav-number">3.1.2.</span> <span class="nav-text">Character device</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Pipe-device"><span class="nav-number">3.1.3.</span> <span class="nav-text">Pipe device</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Socket-device"><span class="nav-number">3.2.</span> <span class="nav-text">Socket device</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-sysfs-Device-Path"><span class="nav-number">3.3.</span> <span class="nav-text">The sysfs Device Path</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dd-and-Devices"><span class="nav-number">3.4.</span> <span class="nav-text">dd and Devices</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Device-Name-Summary"><span class="nav-number">3.5.</span> <span class="nav-text">Device Name Summary</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-4-Disks-and-Filesystems"><span class="nav-number">4.</span> <span class="nav-text">Chapter 4. Disks and Filesystems</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Partitioning-Disk-Devices"><span class="nav-number">4.1.</span> <span class="nav-text">Partitioning Disk Devices</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Changing-Partition-Tables"><span class="nav-number">4.2.</span> <span class="nav-text">Changing Partition Tables</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Filesystems"><span class="nav-number">4.3.</span> <span class="nav-text">Filesystems</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Filesystem-Types"><span class="nav-number">4.3.1.</span> <span class="nav-text">Filesystem Types</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Create-a-Filesystems"><span class="nav-number">4.3.2.</span> <span class="nav-text">Create a Filesystems</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Mounting-a-Filesystem"><span class="nav-number">4.3.3.</span> <span class="nav-text">Mounting a Filesystem</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Filesystem-UUID"><span class="nav-number">4.3.4.</span> <span class="nav-text">Filesystem UUID</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Disk-Buffering-Caching-and-Filesystems"><span class="nav-number">4.3.5.</span> <span class="nav-text">Disk Buffering, Caching, and Filesystems</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#The-etc-fstab-Filesystem-Table"><span class="nav-number">4.3.6.</span> <span class="nav-text">The /etc/fstab Filesystem Table</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Filesystem-Capacity"><span class="nav-number">4.3.7.</span> <span class="nav-text">Filesystem Capacity</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Checking-and-Repairing-Filesystems"><span class="nav-number">4.3.8.</span> <span class="nav-text">Checking and Repairing Filesystems</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Special-Purpose-Filesystems"><span class="nav-number">4.3.9.</span> <span class="nav-text">Special-Purpose Filesystems</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Swap-Space"><span class="nav-number">4.4.</span> <span class="nav-text">Swap Space</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Looking-Forward-Disks-and-User-Space"><span class="nav-number">4.5.</span> <span class="nav-text">Looking Forward: Disks and User Space</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-5-How-the-Linux-Kernel-Boots"><span class="nav-number">5.</span> <span class="nav-text">Chapter 5. How the Linux Kernel Boots</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Startup-Messages"><span class="nav-number">5.1.</span> <span class="nav-text">Startup Messages</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kernel-Initialization-and-Boot-Options"><span class="nav-number">5.2.</span> <span class="nav-text">Kernel Initialization and Boot Options</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Kernel-Parameters"><span class="nav-number">5.3.</span> <span class="nav-text">Kernel Parameters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Boot-Loader"><span class="nav-number">5.4.</span> <span class="nav-text">Boot Loader</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Boot-loader-tasks"><span class="nav-number">5.4.1.</span> <span class="nav-text">Boot loader tasks</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Boot-loader-typres"><span class="nav-number">5.4.2.</span> <span class="nav-text">Boot loader typres</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GRUB-Introduction"><span class="nav-number">5.5.</span> <span class="nav-text">GRUB Introduction</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-6-How-User-Space-Starts"><span class="nav-number">6.</span> <span class="nav-text">Chapter 6. How User Space Starts</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Introduction-to-init"><span class="nav-number">6.1.</span> <span class="nav-text">Introduction to init</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#System-V-Runlevels"><span class="nav-number">6.2.</span> <span class="nav-text">System V Runlevels</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Identifying-Your-init"><span class="nav-number">6.3.</span> <span class="nav-text">Identifying Your init</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#systemd"><span class="nav-number">6.4.</span> <span class="nav-text">systemd</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Units-and-Unit-Types"><span class="nav-number">6.4.1.</span> <span class="nav-text">Units and Unit Types</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#systemd-Dependencies"><span class="nav-number">6.4.2.</span> <span class="nav-text">systemd Dependencies</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#systemd-Configuration"><span class="nav-number">6.4.3.</span> <span class="nav-text">systemd Configuration</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#systemd-Operation"><span class="nav-number">6.5.</span> <span class="nav-text">systemd Operation</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#systemd-Process-Tracking-and-Synchronization"><span class="nav-number">6.5.1.</span> <span class="nav-text">systemd Process Tracking and Synchronization</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#systemd-On-Demand-and-Resource-Parallelized-Startup"><span class="nav-number">6.5.2.</span> <span class="nav-text">systemd On-Demand and Resource-Parallelized Startup</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#systemd-Auxiliary-Programs"><span class="nav-number">6.5.3.</span> <span class="nav-text">systemd Auxiliary Programs</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Shutting-Down-Your-System"><span class="nav-number">6.6.</span> <span class="nav-text">Shutting Down Your System</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Initial-RAM-Filesystem"><span class="nav-number">6.7.</span> <span class="nav-text">The Initial RAM Filesystem</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-7-System-Configuration"><span class="nav-number">7.</span> <span class="nav-text">Chapter 7. System Configuration</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chengdong Liao</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v6.7.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  

  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  



  











  





  

  

  

  

  

  

  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap');
      $(e).after($wrap);
      $wrap.append($('<button>').addClass('copy-btn').append('Copy').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text();
        }).toArray().join('\n');
        var ta = document.createElement('textarea');
        var range = document.createRange(); //For Chrome
        var sel = window.getSelection(); //For Chrome
        var yPosition = window.pageYOffset || document.documentElement.scrollTop;
        ta.style.top = yPosition + 'px'; //Prevent page scroll
        ta.style.position = 'absolute';
        ta.style.opacity = '0';
        ta.value = code;
        ta.textContent = code; //For FireFox
        ta.contentEditable = true;
        ta.readOnly = false;
        document.body.appendChild(ta);
        range.selectNode(ta);
        sel.removeAllRanges();
        sel.addRange(range);
        ta.setSelectionRange(0, code.length);
        var result = document.execCommand('copy');
        
          if (result) $(this).text('Copied');
          else $(this).text('Copy failed');
        
        ta.blur(); //For iOS
        $(this).blur();
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn');
        setTimeout(function () {
          $b.text('Copy');
        }, 300);
      }).append(e);
    })
  </script>


  

</body>
</html>
